# Source Transformation Plugin System

## Overview

The designer includes a pluggable architecture for last-minute source code corrections before saving. This allows for:

- **Whitespace normalization** - Preserve original indentation style
- **Linting/formatting** - Apply code style rules
- **Comment preservation** - Restore comments from original source
- **Future: LLM arbitration** - Use AI to intelligently merge changes

## Architecture

```
Edits Applied → Candidate Source → Transformer → Final Source → Save
```

The transformer sits between edit application and file save, giving a chance for final adjustments.

## Interface

```typescript
interface SourceTransformer {
  name: string;
  transform(context: TransformContext): TransformResult | Promise<TransformResult>;
}

interface TransformContext {
  originalSource: string;      // Before designer edits
  candidateSource: string;      // After designer edits
  filePath: string;
  metadata: any;
  edits: any[];
}

interface TransformResult {
  source: string;               // Final source to save
  warnings?: string[];          // Optional warnings to log
  transformed: boolean;         // Whether any changes were made
}
```

## Built-in Transformers

### NoOpTransformer (Default)

Returns candidate source unchanged. Used by default.

```typescript
import { transformerRegistry, NoOpTransformer } from './transformers';

// Reset to default
transformerRegistry.setTransformer(new NoOpTransformer());
```

### WhitespaceNormalizer

Preserves original file's indentation style (tabs vs spaces, indent width).

```typescript
import { transformerRegistry, WhitespaceNormalizer } from './transformers';

transformerRegistry.setTransformer(new WhitespaceNormalizer());
```

**Example:**
- Original uses 4 spaces
- Designer generates with 2 spaces
- Normalizer converts back to 4 spaces

### CommentPreserver

Attempts to restore inline comments from original source by matching line content.

```typescript
import { transformerRegistry, CommentPreserver } from './transformers';

transformerRegistry.setTransformer(new CommentPreserver());
```

**Example:**
```typescript
// Original:
button("Click").withId('btn'); // Primary action

// After edit (comment lost):
button("Click Me").withId('btn');

// After CommentPreserver:
button("Click Me").withId('btn'); // Primary action
```

**Limitations:**
- Only works for inline (`//`) comments
- Requires line content match
- May fail if code structure changes significantly

### CompositeTransformer

Chains multiple transformers together.

```typescript
import {
  transformerRegistry,
  CompositeTransformer,
  WhitespaceNormalizer,
  CommentPreserver
} from './transformers';

const composite = new CompositeTransformer([
  new WhitespaceNormalizer(),
  new CommentPreserver()
]);

transformerRegistry.setTransformer(composite);
```

Transformers execute in order, each receiving the output of the previous.

## Creating Custom Transformers

```typescript
import { SourceTransformer, TransformContext, TransformResult } from './transformers';

class MyCustomTransformer implements SourceTransformer {
  name = 'MyCustomTransformer';

  transform(context: TransformContext): TransformResult {
    const { originalSource, candidateSource } = context;

    // Your transformation logic here
    let finalSource = candidateSource;
    let transformed = false;
    const warnings: string[] = [];

    // Example: Add a header comment
    if (!candidateSource.startsWith('//')) {
      finalSource = `// Generated by designer\n${candidateSource}`;
      transformed = true;
    }

    return {
      source: finalSource,
      transformed,
      warnings
    };
  }
}

// Register it
import { transformerRegistry } from './transformers';
transformerRegistry.setTransformer(new MyCustomTransformer());
```

## Async Transformers

Transformers can be async for I/O operations or API calls:

```typescript
class AsyncTransformer implements SourceTransformer {
  name = 'AsyncTransformer';

  async transform(context: TransformContext): Promise<TransformResult> {
    // Call external service
    const result = await fetch('https://api.formatter.com/format', {
      method: 'POST',
      body: context.candidateSource
    });

    const formatted = await result.text();

    return {
      source: formatted,
      transformed: true
    };
  }
}
```

## Future: LLM Transformer

The architecture supports LLM-based transformation (currently stub):

```typescript
import { LLMTransformer, transformerRegistry } from './transformers';

const llmTransformer = new LLMTransformer(
  process.env.ANTHROPIC_API_KEY,
  'claude-3-5-sonnet-20241022'
);

transformerRegistry.setTransformer(llmTransformer);
```

**Concept:**
1. Send original + candidate source to LLM
2. Ask it to intelligently merge:
   - Preserve formatting
   - Restore comments
   - Maintain code style
3. Return merged source

## Configuration

### Via Code (server startup)

```typescript
// In server.ts
import { transformerRegistry, WhitespaceNormalizer } from './transformers';

// Set transformer at startup
transformerRegistry.setTransformer(new WhitespaceNormalizer());
```

### Via API Endpoint (Future)

```typescript
// POST /api/set-transformer
{
  "transformer": "WhitespaceNormalizer"
}
```

## Testing Transformers

Test transformers by verifying output:

```typescript
import { WhitespaceNormalizer } from './transformers';

const transformer = new WhitespaceNormalizer();

const result = await transformer.transform({
  originalSource: "app(() => {\n    vbox();\n});",  // 4 spaces
  candidateSource: "app(() => {\n  vbox();\n});",  // 2 spaces
  filePath: 'test.ts',
  metadata: {},
  edits: []
});

expect(result.source).toContain('    vbox()'); // Back to 4 spaces
expect(result.transformed).toBe(true);
```

## Debugging

Transformers log their activity:

```
[Transformer] Using transformer: WhitespaceNormalizer
[Transformer] Applied transformations
[Transformer] Normalized indentation from '  ' to '    '
```

Check console output when saving to see transformer behavior.

## Best Practices

1. **Keep transformers focused** - One responsibility per transformer
2. **Use CompositeTransformer** - Chain simple transformers instead of one complex one
3. **Return warnings** - Help users understand what changed
4. **Test edge cases** - Empty files, malformed code, etc.
5. **Be defensive** - Transformers shouldn't crash the save operation

## Performance

Transformers run on every save. Keep them fast:

- ✅ String operations - Fast
- ✅ Regex matching - Fast
- ⚠️  AST parsing - Moderate (cache if possible)
- ❌ API calls - Slow (use sparingly)

## Error Handling

Transformers should handle errors gracefully:

```typescript
class SafeTransformer implements SourceTransformer {
  name = 'SafeTransformer';

  async transform(context: TransformContext): Promise<TransformResult> {
    try {
      // Risky transformation
      const result = await riskyOperation(context.candidateSource);
      return { source: result, transformed: true };
    } catch (error) {
      // Fall back to candidate source
      return {
        source: context.candidateSource,
        transformed: false,
        warnings: [`Transformation failed: ${error.message}`]
      };
    }
  }
}
```

This ensures saves don't fail due to transformer errors.
